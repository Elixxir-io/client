// Code generated by protoc-gen-go. DO NOT EDIT.
// source: types.proto

package cmixproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Type int32

const (
	// Used as a wildcard for listeners to listen to all existing types.
	// Think of it as "No type in particular"
	Type_NO_TYPE Type = 0
	// See proto buf documentation below
	Type_TEXT_MESSAGE Type = 1
	// See proto buf
	Type_CHANNEL_MESSAGE Type = 2
	// Second field is the key data itself. This should be 2048 bits long
	// (according to the message length that our prime allows) and is
	// base64-encoded.
	Type_UDB_PUSH_KEY Type = 10
	// The push key response message is a string. If the key push was a
	// success, the UDB should respond with a message that starts with "PUSHKEY
	// COMPLETE", followed by the fingerprint of the key that was pushed.
	// If the response doesn't begin with "PUSHKEY COMPLETE", the message is
	// an error message and should be shown to the user.
	Type_UDB_PUSH_KEY_RESPONSE Type = 11
	// The get key message includes a single string field with the key
	// fingerprint of the key that needs gettin'. This is the same fingerprint
	// you would have pushed.
	Type_UDB_GET_KEY Type = 12
	// The get key response message is a string. The first space-separated
	// field should always be "GETKEY". The second field is the fingerprint of
	// the key. The third field is "NOTFOUND" if the UDB didn't find the key,
	// or the key itself, encoded in base64, otherwise.
	Type_UDB_GET_KEY_RESPONSE Type = 13
	// To wit: The first argument in the list of space-separated fields is
	// the type of the registration. Currently the only allowed type is
	// "EMAIL". The second argument is the value of the type you're registering
	// with. In all currently acceptable registration types, this would be an
	// email address. If you could register with your phone, it would be your
	// phone number, and so on. Then, the key fingerprint of the user's key is
	// the third argument. To register successfully, you must have already
	// pushed the key with that fingerprint.
	Type_UDB_REGISTER Type = 14
	// The registration response is just a string. It will be either an error
	// message to show to the user, or the message "REGISTRATION COMPLETE" if
	// registration was successful.
	Type_UDB_REGISTER_RESPONSE Type = 15
	// The search message is just another space separated list. The first field
	// will contain the type of registered user you're searching for, namely
	// "EMAIL". The second field with contain the value of that type that
	// you're searching for.
	Type_UDB_SEARCH Type = 16
	// The search response is a list of fields. The first is always "SEARCH".
	// The second is always the value that the user searched for. The third is
	// "FOUND" or "NOTFOUND" depending on whether the UDB found the user. If
	// the user was FOUND, the last field will contain their key fingerprint,
	// which you can use with GET_KEY to get the keys you need to talk with
	// that user. Otherwise, this fourth field won't exist.
	Type_UDB_SEARCH_RESPONSE Type = 17
	// To get a message of this type, call the methods in the wallet.
	// TODO expose these methods over the API
	Type_PAYMENT_TRANSACTION Type = 20
	// See proto buf
	Type_PAYMENT_RESPONSE Type = 21
	// See proto buf
	Type_PAYMENT_INVOICE Type = 22
	// This message type includes only the message hash of the original
	// invoice message. Since there are no fields to delimit, it's not a
	// proto buffer. When the payee gets a receipt back, they know that the
	// other person probably paid them, and to check the next published
	// blockchain for the images of their coins to make sure.
	// The wallet sends this message after receiving a PAYMENT_RESPONSE
	// indicating success.
	Type_PAYMENT_RECEIPT Type = 23
	// This message type is a single fixed-length hash of the invoice
	// that the client just received. The client can look up this hash in the
	// inbound transaction list to display the most recently received invoice
	// in the UI.
	Type_PAYMENT_INVOICE_UI Type = 9000
	// This message type is a single fixed-length hash of the original invoice
	// that this client sent to the paying client. The UI can look up the
	// corresponding transaction in the list of completed transactions and
	// display payment success on the UI. The wallet sends this message
	// locally after receiving a PAYMENT_RECEIPT message.
	Type_PAYMENT_RECEIPT_UI Type = 9001
)

var Type_name = map[int32]string{
	0:    "NO_TYPE",
	1:    "TEXT_MESSAGE",
	2:    "CHANNEL_MESSAGE",
	10:   "UDB_PUSH_KEY",
	11:   "UDB_PUSH_KEY_RESPONSE",
	12:   "UDB_GET_KEY",
	13:   "UDB_GET_KEY_RESPONSE",
	14:   "UDB_REGISTER",
	15:   "UDB_REGISTER_RESPONSE",
	16:   "UDB_SEARCH",
	17:   "UDB_SEARCH_RESPONSE",
	20:   "PAYMENT_TRANSACTION",
	21:   "PAYMENT_RESPONSE",
	22:   "PAYMENT_INVOICE",
	23:   "PAYMENT_RECEIPT",
	9000: "PAYMENT_INVOICE_UI",
	9001: "PAYMENT_RECEIPT_UI",
}
var Type_value = map[string]int32{
	"NO_TYPE":               0,
	"TEXT_MESSAGE":          1,
	"CHANNEL_MESSAGE":       2,
	"UDB_PUSH_KEY":          10,
	"UDB_PUSH_KEY_RESPONSE": 11,
	"UDB_GET_KEY":           12,
	"UDB_GET_KEY_RESPONSE":  13,
	"UDB_REGISTER":          14,
	"UDB_REGISTER_RESPONSE": 15,
	"UDB_SEARCH":            16,
	"UDB_SEARCH_RESPONSE":   17,
	"PAYMENT_TRANSACTION":   20,
	"PAYMENT_RESPONSE":      21,
	"PAYMENT_INVOICE":       22,
	"PAYMENT_RECEIPT":       23,
	"PAYMENT_INVOICE_UI":    9000,
	"PAYMENT_RECEIPT_UI":    9001,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}
func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_05dacacbf2476fc7, []int{0}
}

// Is Type.TEXT_MESSAGE
// Used for conveying simple text messages between users
type TextMessage struct {
	// Terminal text foreground color. Used by the console UI
	Color int32 `protobuf:"zigzag32,2,opt,name=color,proto3" json:"color,omitempty"`
	// The message text itself. Varies in length
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// Timestamp (Unix time in seconds)
	// You can use this to display the time when the other user sent the message
	// TODO Remove this when all messages have timestamps
	Time                 int64    `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TextMessage) Reset()         { *m = TextMessage{} }
func (m *TextMessage) String() string { return proto.CompactTextString(m) }
func (*TextMessage) ProtoMessage()    {}
func (*TextMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_05dacacbf2476fc7, []int{0}
}
func (m *TextMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TextMessage.Unmarshal(m, b)
}
func (m *TextMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TextMessage.Marshal(b, m, deterministic)
}
func (dst *TextMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextMessage.Merge(dst, src)
}
func (m *TextMessage) XXX_Size() int {
	return xxx_messageInfo_TextMessage.Size(m)
}
func (m *TextMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TextMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TextMessage proto.InternalMessageInfo

func (m *TextMessage) GetColor() int32 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *TextMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TextMessage) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

// Is Type.CHANNEL_MESSAGE
// This is the type of all messages that come from the channelbot.
type ChannelMessage struct {
	// This is the original speaker of the channel message, who sent the
	// message to the channel bot.
	SpeakerID []byte `protobuf:"bytes,3,opt,name=speakerID,proto3" json:"speakerID,omitempty"`
	// This is a serialized parse message under the hood. When writing a
	// listener for a channel message on a client, you need to unpack the
	// serialized parse message and rebroadcast it through the listeners.
	Message              []byte   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelMessage) Reset()         { *m = ChannelMessage{} }
func (m *ChannelMessage) String() string { return proto.CompactTextString(m) }
func (*ChannelMessage) ProtoMessage()    {}
func (*ChannelMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_05dacacbf2476fc7, []int{1}
}
func (m *ChannelMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelMessage.Unmarshal(m, b)
}
func (m *ChannelMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelMessage.Marshal(b, m, deterministic)
}
func (dst *ChannelMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelMessage.Merge(dst, src)
}
func (m *ChannelMessage) XXX_Size() int {
	return xxx_messageInfo_ChannelMessage.Size(m)
}
func (m *ChannelMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelMessage proto.InternalMessageInfo

func (m *ChannelMessage) GetSpeakerID() []byte {
	if m != nil {
		return m.SpeakerID
	}
	return nil
}

func (m *ChannelMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

// Is Type.PAYMENT_RESPONSE
type PaymentResponse struct {
	// Indicates whether the payment succeeded or failed
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Response message from the payment bot. You should display this to the
	// user.
	Response string `protobuf:"bytes,2,opt,name=response,proto3" json:"response,omitempty"`
	// TODO Is it correct to use the whole hash?
	// This is the hash of the payment message that the payment bot received.
	// The client uses it to remove the correct pending transaction from the
	// list of pending transactions.
	ID                   string   `protobuf:"bytes,3,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentResponse) Reset()         { *m = PaymentResponse{} }
func (m *PaymentResponse) String() string { return proto.CompactTextString(m) }
func (*PaymentResponse) ProtoMessage()    {}
func (*PaymentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_05dacacbf2476fc7, []int{2}
}
func (m *PaymentResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PaymentResponse.Unmarshal(m, b)
}
func (m *PaymentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PaymentResponse.Marshal(b, m, deterministic)
}
func (dst *PaymentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentResponse.Merge(dst, src)
}
func (m *PaymentResponse) XXX_Size() int {
	return xxx_messageInfo_PaymentResponse.Size(m)
}
func (m *PaymentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentResponse proto.InternalMessageInfo

func (m *PaymentResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *PaymentResponse) GetResponse() string {
	if m != nil {
		return m.Response
	}
	return ""
}

func (m *PaymentResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

// Is Type.PAYMENT_INVOICE
type PaymentInvoice struct {
	// Timestamp (Unix time in seconds)
	// Not currently used but could be useful for the user to verify the
	// correctness of an invoice.
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	// This is a single compound coin that the invoicer wants to be funded. The
	// payer should send a message to the payment bot to fund this compound, if
	// they wish to pay the payee.
	CreatedCoin []byte `protobuf:"bytes,2,opt,name=createdCoin,proto3" json:"createdCoin,omitempty"`
	// The payee should fill this out to describe what the payment is for or
	// about.
	Memo                 string   `protobuf:"bytes,3,opt,name=memo,proto3" json:"memo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentInvoice) Reset()         { *m = PaymentInvoice{} }
func (m *PaymentInvoice) String() string { return proto.CompactTextString(m) }
func (*PaymentInvoice) ProtoMessage()    {}
func (*PaymentInvoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_05dacacbf2476fc7, []int{3}
}
func (m *PaymentInvoice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PaymentInvoice.Unmarshal(m, b)
}
func (m *PaymentInvoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PaymentInvoice.Marshal(b, m, deterministic)
}
func (dst *PaymentInvoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentInvoice.Merge(dst, src)
}
func (m *PaymentInvoice) XXX_Size() int {
	return xxx_messageInfo_PaymentInvoice.Size(m)
}
func (m *PaymentInvoice) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentInvoice.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentInvoice proto.InternalMessageInfo

func (m *PaymentInvoice) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *PaymentInvoice) GetCreatedCoin() []byte {
	if m != nil {
		return m.CreatedCoin
	}
	return nil
}

func (m *PaymentInvoice) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func init() {
	proto.RegisterType((*TextMessage)(nil), "parse.TextMessage")
	proto.RegisterType((*ChannelMessage)(nil), "parse.ChannelMessage")
	proto.RegisterType((*PaymentResponse)(nil), "parse.PaymentResponse")
	proto.RegisterType((*PaymentInvoice)(nil), "parse.PaymentInvoice")
	proto.RegisterEnum("parse.Type", Type_name, Type_value)
}

func init() { proto.RegisterFile("types.proto", fileDescriptor_types_05dacacbf2476fc7) }

var fileDescriptor_types_05dacacbf2476fc7 = []byte{
	// 452 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x92, 0xdf, 0x72, 0x93, 0x40,
	0x14, 0xc6, 0x85, 0xa6, 0xb6, 0x1c, 0x22, 0xd9, 0x9e, 0xa6, 0x16, 0x1d, 0x2f, 0x98, 0x5c, 0x65,
	0xbc, 0xf0, 0xc6, 0x27, 0xa0, 0x64, 0x9b, 0x30, 0x1a, 0x82, 0xcb, 0x46, 0x4d, 0x6f, 0x18, 0xc4,
	0x1d, 0xcd, 0x58, 0xfe, 0x0c, 0x8b, 0x4e, 0xf3, 0x46, 0xfa, 0x7c, 0xbe, 0x80, 0x03, 0x65, 0x03,
	0xe3, 0x15, 0xe7, 0xfb, 0xbe, 0x1f, 0xdf, 0xee, 0x99, 0x59, 0x30, 0xeb, 0x43, 0x29, 0xe4, 0x9b,
	0xb2, 0x2a, 0xea, 0x02, 0x4f, 0xcb, 0xa4, 0x92, 0x62, 0xf6, 0x01, 0x4c, 0x2e, 0x1e, 0xea, 0xb5,
	0x90, 0x32, 0xf9, 0x26, 0x70, 0x0a, 0xa7, 0x69, 0x71, 0x5f, 0x54, 0xb6, 0xee, 0x68, 0xf3, 0x0b,
	0xf6, 0x28, 0xd0, 0x86, 0xb3, 0xec, 0x11, 0xb0, 0x4f, 0x1c, 0x6d, 0x6e, 0x30, 0x25, 0x11, 0x61,
	0x54, 0xef, 0x33, 0x61, 0x8f, 0x1c, 0x6d, 0x7e, 0xc2, 0xda, 0x79, 0xb6, 0x02, 0xcb, 0xfb, 0x9e,
	0xe4, 0xb9, 0xb8, 0x57, 0xad, 0xaf, 0xc0, 0x90, 0xa5, 0x48, 0x7e, 0x88, 0xca, 0x5f, 0xb4, 0x0d,
	0x63, 0xd6, 0x1b, 0xc3, 0xf6, 0x51, 0x9b, 0x29, 0x39, 0xfb, 0x04, 0x93, 0x30, 0x39, 0x64, 0x22,
	0xaf, 0x99, 0x90, 0x65, 0x91, 0x4b, 0xd1, 0xc0, 0xf2, 0x67, 0x9a, 0x0a, 0x29, 0x6d, 0xcd, 0xd1,
	0xe6, 0xe7, 0x4c, 0x49, 0x7c, 0x09, 0xe7, 0x55, 0x47, 0xb5, 0xb7, 0x37, 0xd8, 0x51, 0xa3, 0x05,
	0x7a, 0x77, 0xb2, 0xc1, 0x74, 0x7f, 0x31, 0xbb, 0x03, 0xab, 0x2b, 0xf6, 0xf3, 0x5f, 0xc5, 0x3e,
	0xed, 0x17, 0xd1, 0xfa, 0x45, 0xd0, 0x01, 0x33, 0xad, 0x44, 0x52, 0x8b, 0xaf, 0x5e, 0xb1, 0xcf,
	0xdb, 0xd2, 0x31, 0x1b, 0x5a, 0xcd, 0x5f, 0x99, 0xc8, 0x8a, 0xae, 0xb9, 0x9d, 0x5f, 0xff, 0xd5,
	0x61, 0xc4, 0x0f, 0xa5, 0x40, 0x13, 0xce, 0x82, 0x4d, 0xcc, 0x77, 0x21, 0x25, 0x4f, 0x90, 0xc0,
	0x98, 0xd3, 0xcf, 0x3c, 0x5e, 0xd3, 0x28, 0x72, 0x97, 0x94, 0x68, 0x78, 0x09, 0x13, 0x6f, 0xe5,
	0x06, 0x01, 0x7d, 0x7f, 0x34, 0xf5, 0x06, 0xdb, 0x2e, 0x6e, 0xe2, 0x70, 0x1b, 0xad, 0xe2, 0x77,
	0x74, 0x47, 0x00, 0x5f, 0xc0, 0xd5, 0xd0, 0x89, 0x19, 0x8d, 0xc2, 0x4d, 0x10, 0x51, 0x62, 0xe2,
	0x04, 0xcc, 0x26, 0x5a, 0x52, 0xde, 0xb2, 0x63, 0xb4, 0x61, 0x3a, 0x30, 0x7a, 0xf4, 0x99, 0xea,
	0x65, 0x74, 0xe9, 0x47, 0x9c, 0x32, 0x62, 0xa9, 0x5e, 0xe5, 0xf4, 0xf0, 0x04, 0x2d, 0x80, 0x26,
	0x8a, 0xa8, 0xcb, 0xbc, 0x15, 0x21, 0x78, 0x0d, 0x97, 0xbd, 0xee, 0xc1, 0x8b, 0x26, 0x08, 0xdd,
	0xdd, 0x9a, 0x06, 0x3c, 0xe6, 0xcc, 0x0d, 0x22, 0xd7, 0xe3, 0xfe, 0x26, 0x20, 0x53, 0x9c, 0x02,
	0x51, 0xc1, 0x11, 0xbf, 0x6a, 0x36, 0x56, 0xae, 0x1f, 0x7c, 0xdc, 0xf8, 0x1e, 0x25, 0xcf, 0x87,
	0x26, 0xa3, 0x1e, 0xf5, 0x43, 0x4e, 0xae, 0xf1, 0x1a, 0xf0, 0x3f, 0x32, 0xde, 0xfa, 0xe4, 0xf7,
	0xed, 0x30, 0xe8, 0xe8, 0x26, 0xf8, 0x73, 0x7b, 0x63, 0xde, 0x19, 0x69, 0xb6, 0x7f, 0x68, 0xdf,
	0xf6, 0x97, 0xa7, 0xed, 0xe7, 0xed, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x22, 0x10, 0xad,
	0xf1, 0x02, 0x00, 0x00,
}
