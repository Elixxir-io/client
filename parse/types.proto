////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2018 Privategrity Corporation                                   /
//                                                                             /
// All rights reserved.                                                        /
////////////////////////////////////////////////////////////////////////////////

// Call ./generate.sh to generate the protocol buffer code

syntax = "proto3";

package parse;
option go_package = "parse";

enum Type {
    // Used as a wildcard for listeners to listen to all existing types.
    // Think of it as "No type in particular"
    NO_TYPE = 0;


    // See proto buf documentation below
    TEXT_MESSAGE = 1;
    // See proto buf
    CHANNEL_MESSAGE = 2;


    // None of the UDB message types are proto bufs because I haven't had time
    // to migrate UDB fully to the new systems yet.

    // I was considering migrating these types to proto bufs to make them more
    // compact for transmission, but you would have to compress them to even
    // have a chance of fitting the whole key in one Cmix message. In any case,
    // I don't think the benefit is there for the time investment.

    // The prefixes of the UDB response messages are made redundant by the
    // message types in this very enumeration, so at some point we can remove
    // them from the UDB code that generates the responses.


    // The push key message includes two string fields, separated by a space.
    
    // First field is the key fingerprint, which the UDB uses as an key into
    // the map of, uhh, the keys. This can be any string that doesn't have a
    // space in it.
    
    // Second field is the key data itself. This should be 2048 bits long
    // (according to the message length that our prime allows) and is
    // base64-encoded.
    UDB_PUSH_KEY = 10;
    // The push key response message is a string. If the key push was a
    // success, the UDB should respond with a message that starts with "PUSHKEY
    // COMPLETE", followed by the fingerprint of the key that was pushed.
    // If the response doesn't begin with "PUSHKEY COMPLETE", the message is
    // an error message and should be shown to the user.
    UDB_PUSH_KEY_RESPONSE = 11;
    // The get key message includes a single string field with the key
    // fingerprint of the key that needs gettin'. This is the same fingerprint
    // you would have pushed.
    UDB_GET_KEY = 12;
    // The get key response message is a string. The first space-separated
    // field should always be "GETKEY". The second field is the fingerprint of
    // the key. The third field is "NOTFOUND" if the UDB didn't find the key,
    // or the key itself, encoded in base64, otherwise.
    UDB_GET_KEY_RESPONSE = 13;
    // The register message is unchanged from the OG UDB code, except that
    // the REGISTER command in front has been replaced with the type string
    // corresponding to this entry in the enumeration.

    // To wit: The first argument in the list of space-separated fields is
    // the type of the registration. Currently the only allowed type is
    // "EMAIL". The second argument is the value of the type you're registering
    // with. In all currently acceptable registration types, this would be an
    // email address. If you could register with your phone, it would be your
    // phone number, and so on. Then, the key fingerprint of the user's key is
    // the third argument. To register successfully, you must have already
    // pushed the key with that fingerprint.
    UDB_REGISTER = 14;
    // The registration response is just a string. It will be either an error
    // message to show to the user, or the message "REGISTRATION COMPLETE" if
    // registration was successful.
    UDB_REGISTER_RESPONSE = 15;
    // The search message is just another space separated list. The first field
    // will contain the type of registered user you're searching for, namely
    // "EMAIL". The second field with contain the value of that type that
    // you're searching for.
    UDB_SEARCH = 16;
    // The search response is a list of fields. The first is always "SEARCH".
    // The second is always the value that the user searched for. The third is
    // "FOUND" or "NOTFOUND" depending on whether the UDB found the user. If
    // the user was FOUND, the last field will contain their key fingerprint,
    // which you can use with GET_KEY to get the keys you need to talk with
    // that user. Otherwise, this fourth field won't exist.
    UDB_SEARCH_RESPONSE = 17;


    // The client sends payment transaction messages to the payment bot to
    // fund compound coins with seed coins. In the current implementation,
    // there's one compound that gets funded that's from the payee. This comes
    // across in a PAYMENT_INVOICE. And there's a second compound that contains
    // the change from the seeds that the payer is using to fund the invoice.
    // The rest are the seeds that are the source of the payment.

    // All of the seeds and compounds are in an ordered list, and they get
    // categorized and processed on the payment bot.

    // To get a message of this type, call the methods in the wallet.
    // TODO expose these methods over the API
    PAYMENT_TRANSACTION = 20;
    // See proto buf
    PAYMENT_RESPONSE = 21;
    // See proto buf
    PAYMENT_INVOICE = 22;
}

// Text message types

// Is Type.TEXT_MESSAGE
// Used for conveying simple text messages between users
message TextMessage {
    // Terminal text foreground color. Used by the console UI
    sint32 color = 2;
    // The message text itself. Varies in length
    string message = 3;
    // Timestamp (Unix time in seconds)
    // You can use this to display the time when the other user sent the message
    // TODO Remove this when all messages have timestamps
    int64 time = 4;
}

// Is Type.CHANNEL_MESSAGE
// This is the type of all messages that come from the channelbot.
message ChannelMessage {
    // This is the original speaker of the channel message, who sent the
    // message to the channel bot.
    bytes speakerID = 3;
    // This is a serialized parse message under the hood. When writing a
    // listener for a channel message on a client, you need to unpack the
    // serialized parse message and rebroadcast it through the listeners.
    bytes message = 4;
}

// Payment message types

// Is Type.PAYMENT_RESPONSE
message PaymentResponse {
    // Indicates whether the payment succeeded or failed
    bool success = 1;
    // Response message from the payment bot. You should display this to the
    // user.
    string response = 2;
    // TODO Is it correct to use the whole hash?
    // This is the hash of the payment message that the payment bot received.
    // The client uses it to remove the correct pending transaction from the
    // list of pending transactions.
    string ID = 3;
}

// Is Type.PAYMENT_INVOICE
message PaymentInvoice {
    // Timestamp (Unix time in seconds)
    // Not currently used but could be useful for the user to verify the
    // correctness of an invoice.
    int64 time = 1;
    // This is a single compound coin that the invoicer wants to be funded. The
    // payer should send a message to the payment bot to fund this compound, if
    // they wish to pay the payee.
    bytes createdCoin = 2;
    // The payee should fill this out to describe what the payment is for or
    // about.
    string memo = 3;
}
