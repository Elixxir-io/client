////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2018 Privategrity Corporation                                   /
//                                                                             /
// All rights reserved.                                                        /
////////////////////////////////////////////////////////////////////////////////

// Call ./generate.sh to generate the protocol buffer code

syntax = "proto3";

package parse;
option go_package = "parse";

enum Type {
    // Used as a wildcard for listeners to listen to all existing types.
    // Think of it as "No type in particular"
    NO_TYPE = 0;
    // See proto buf documentation below
    TEXT_MESSAGE = 1;
    // See proto buf
    CHANNEL_MESSAGE = 2;
    //
    UDB_PUSH_KEY = 10;
    UDB_PUSH_KEY_RESPONSE = 11;
    UDB_GET_KEY = 12;
    UDB_GET_KEY_RESPONSE = 13;
    UDB_REGISTER = 14;
    UDB_REGISTER_RESPONSE = 15;
    UDB_SEARCH = 16;
    UDB_SEARCH_RESPONSE = 17;
    // The client sends payment transaction messages to the payment bot to
    // fund compound coins with seed coins. In the current implementation,
    // there's one compound that gets funded that's from the payee. This comes
    // across in a PAYMENT_INVOICE. And there's a second compound that contains
    // the change from the seeds that the payer is using to fund the invoice.
    // The rest are the seeds that are the source of the payment.
    //      All of the seeds and compounds are in an ordered list, and they get
    // categorized and processed on the payment bot.
    //      To get a message of this type, call the methods in the wallet.
    // TODO expose these methods over the API
    PAYMENT_TRANSACTION = 20;
    // See proto buf
    PAYMENT_RESPONSE = 21;
    // See proto buf
    PAYMENT_INVOICE = 22;
}

// Text message types

// Is Type.TEXT_MESSAGE
// Used for conveying simple text messages between users
message TextMessage {
    // Terminal text foreground color. Used by the console UI
    sint32 color = 2;
    // The message text itself. Varies in length
    string message = 3;
    // Timestamp (Unix time in seconds)
    // You can use this to display the time when the other user sent the message
    // TODO Remove this when all messages have timestamps
    int64 time = 4;
}

// Is Type.CHANNEL_MESSAGE
// This is the type of all messages that come from the channelbot.
message ChannelMessage {
    // This is the original speaker of the channel message, who sent the
    // message to the channel bot.
    bytes speakerID = 3;
    // This is a serialized parse message under the hood. When writing a
    // listener for a channel message on a client, you need to unpack the
    // serialized parse message and rebroadcast it through the listeners.
    bytes message = 4;
}

// Payment message types

// Is Type.PAYMENT_RESPONSE
message PaymentResponse {
    // Indicates whether the payment succeeded or failed
    bool success = 1;
    // Response message from the payment bot. You should display this to the
    // user.
    string response = 2;
    // TODO Is it correct to use the whole hash?
    // This is the hash of the payment message that the payment bot received.
    // The client uses it to remove the correct pending transaction from the
    // list of pending transactions.
    string ID = 3;
}

// Is Type.PAYMENT_INVOICE
message PaymentInvoice {
    // Timestamp (Unix time in seconds)
    // Not currently used but could be useful for the user to verify the
    // correctness of an invoice.
    int64 time = 1;
    // This is a single compound coin that the invoicer wants to be funded. The
    // payer should send a message to the payment bot to fund this compound, if
    // they wish to pay the payee.
    bytes createdCoin = 2;
    // The payee should fill this out to describe what the payment is for or
    // about.
    string memo = 3;
}
