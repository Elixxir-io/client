// Code generated by protoc-gen-go. DO NOT EDIT.
// source: types.proto

/*
Package parse is a generated protocol buffer package.

It is generated from these files:
	types.proto

It has these top-level messages:
	TextMessage
	ChannelMessage
	PaymentResponse
	PaymentInvoice
*/
package parse

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Type int32

const (
	// Used as a wildcard for listeners to listen to all existing types.
	// Think of it as "No type in particular"
	Type_NO_TYPE Type = 0
	// See proto buf documentation below
	Type_TEXT_MESSAGE Type = 1
	// See proto buf
	Type_CHANNEL_MESSAGE Type = 2
	// We currently parse these types without using proto buffers
	// We use the types, but don't look for proto buffer definitions
	Type_UDB_PUSH_KEY          Type = 10
	Type_UDB_PUSH_KEY_RESPONSE Type = 11
	Type_UDB_GET_KEY           Type = 12
	Type_UDB_GET_KEY_RESPONSE  Type = 13
	Type_UDB_REGISTER          Type = 14
	Type_UDB_REGISTER_RESPONSE Type = 15
	Type_UDB_SEARCH            Type = 16
	Type_UDB_SEARCH_RESPONSE   Type = 17
	// The client sends payment transaction messages to the payment bot to
	// fund compound coins with seed coins. In the current implementation,
	// there's one compound that gets funded that's from the payee. This comes
	// across in a PAYMENT_INVOICE. And there's a second compound that contains
	// the change from the seeds that the payer is using to fund the invoice.
	// The rest are the seeds that are the source of the payment.
	//      All of the seeds and compounds are in an ordered list, and they get
	// categorized and processed on the payment bot.
	//      To get a message of this type, call the methods in the wallet.
	// TODO expose these methods over the API
	Type_PAYMENT_TRANSACTION Type = 20
	// See proto buf
	Type_PAYMENT_RESPONSE Type = 21
	// See proto buf
	Type_PAYMENT_INVOICE Type = 22
)

var Type_name = map[int32]string{
	0:  "NO_TYPE",
	1:  "TEXT_MESSAGE",
	2:  "CHANNEL_MESSAGE",
	10: "UDB_PUSH_KEY",
	11: "UDB_PUSH_KEY_RESPONSE",
	12: "UDB_GET_KEY",
	13: "UDB_GET_KEY_RESPONSE",
	14: "UDB_REGISTER",
	15: "UDB_REGISTER_RESPONSE",
	16: "UDB_SEARCH",
	17: "UDB_SEARCH_RESPONSE",
	20: "PAYMENT_TRANSACTION",
	21: "PAYMENT_RESPONSE",
	22: "PAYMENT_INVOICE",
}
var Type_value = map[string]int32{
	"NO_TYPE":               0,
	"TEXT_MESSAGE":          1,
	"CHANNEL_MESSAGE":       2,
	"UDB_PUSH_KEY":          10,
	"UDB_PUSH_KEY_RESPONSE": 11,
	"UDB_GET_KEY":           12,
	"UDB_GET_KEY_RESPONSE":  13,
	"UDB_REGISTER":          14,
	"UDB_REGISTER_RESPONSE": 15,
	"UDB_SEARCH":            16,
	"UDB_SEARCH_RESPONSE":   17,
	"PAYMENT_TRANSACTION":   20,
	"PAYMENT_RESPONSE":      21,
	"PAYMENT_INVOICE":       22,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}
func (Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Is Type.TEXT_MESSAGE
// Used for conveying simple text messages between users
type TextMessage struct {
	// Terminal text foreground color. Used by the console UI
	Color int32 `protobuf:"zigzag32,2,opt,name=color" json:"color,omitempty"`
	// The message text itself. Varies in length
	Message string `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	// Timestamp (Unix time in seconds)
	// You can use this to display the time when the other user sent the message
	// TODO Remove this when all messages have timestamps
	Time int64 `protobuf:"varint,4,opt,name=time" json:"time,omitempty"`
}

func (m *TextMessage) Reset()                    { *m = TextMessage{} }
func (m *TextMessage) String() string            { return proto.CompactTextString(m) }
func (*TextMessage) ProtoMessage()               {}
func (*TextMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TextMessage) GetColor() int32 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *TextMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TextMessage) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

// Is Type.CHANNEL_MESSAGE
// This is the type of all messages that come from the channelbot.
type ChannelMessage struct {
	// This is the original speaker of the channel message, who sent the
	// message to the channel bot.
	SpeakerID []byte `protobuf:"bytes,3,opt,name=speakerID,proto3" json:"speakerID,omitempty"`
	// This is a serialized parse message under the hood. When writing a
	// listener for a channel message on a client, you need to unpack the
	// serialized parse message and rebroadcast it through the listeners.
	Message []byte `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ChannelMessage) Reset()                    { *m = ChannelMessage{} }
func (m *ChannelMessage) String() string            { return proto.CompactTextString(m) }
func (*ChannelMessage) ProtoMessage()               {}
func (*ChannelMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ChannelMessage) GetSpeakerID() []byte {
	if m != nil {
		return m.SpeakerID
	}
	return nil
}

func (m *ChannelMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

// Is Type.PAYMENT_RESPONSE
type PaymentResponse struct {
	// Indicates whether the payment succeeded or failed
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	// Response message from the payment bot. You should display this to the
	// user.
	Response string `protobuf:"bytes,2,opt,name=response" json:"response,omitempty"`
	// TODO Is it correct to use the whole hash?
	// This is the hash of the payment message that the payment bot received.
	// The client uses it to remove the correct pending transaction from the
	// list of pending transactions.
	ID string `protobuf:"bytes,3,opt,name=ID" json:"ID,omitempty"`
}

func (m *PaymentResponse) Reset()                    { *m = PaymentResponse{} }
func (m *PaymentResponse) String() string            { return proto.CompactTextString(m) }
func (*PaymentResponse) ProtoMessage()               {}
func (*PaymentResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PaymentResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *PaymentResponse) GetResponse() string {
	if m != nil {
		return m.Response
	}
	return ""
}

func (m *PaymentResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

// Is Type.PAYMENT_INVOICE
type PaymentInvoice struct {
	// Timestamp (Unix time in seconds)
	// Not currently used but could be useful for the user to verify the
	// correctness of an invoice.
	Time int64 `protobuf:"varint,1,opt,name=time" json:"time,omitempty"`
	// This is a single compound coin that the invoicer wants to be funded. The
	// payer should send a message to the payment bot to fund this compound, if
	// they wish to pay the payee.
	CreatedCoin []byte `protobuf:"bytes,2,opt,name=createdCoin,proto3" json:"createdCoin,omitempty"`
	// The payee should fill this out to describe what the payment is for or
	// about.
	Memo string `protobuf:"bytes,3,opt,name=memo" json:"memo,omitempty"`
}

func (m *PaymentInvoice) Reset()                    { *m = PaymentInvoice{} }
func (m *PaymentInvoice) String() string            { return proto.CompactTextString(m) }
func (*PaymentInvoice) ProtoMessage()               {}
func (*PaymentInvoice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PaymentInvoice) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *PaymentInvoice) GetCreatedCoin() []byte {
	if m != nil {
		return m.CreatedCoin
	}
	return nil
}

func (m *PaymentInvoice) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func init() {
	proto.RegisterType((*TextMessage)(nil), "parse.TextMessage")
	proto.RegisterType((*ChannelMessage)(nil), "parse.ChannelMessage")
	proto.RegisterType((*PaymentResponse)(nil), "parse.PaymentResponse")
	proto.RegisterType((*PaymentInvoice)(nil), "parse.PaymentInvoice")
	proto.RegisterEnum("parse.Type", Type_name, Type_value)
}

func init() { proto.RegisterFile("types.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 420 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x92, 0x5f, 0x8f, 0x93, 0x40,
	0x14, 0xc5, 0x85, 0xed, 0xda, 0xed, 0xa5, 0xd2, 0xd9, 0xbb, 0x5d, 0x45, 0xe3, 0x03, 0xe9, 0x53,
	0xe3, 0x83, 0x2f, 0x7e, 0x02, 0x96, 0x4e, 0x5a, 0xa2, 0xa5, 0x38, 0xcc, 0xaa, 0xdd, 0x17, 0x82,
	0x78, 0xa3, 0x8d, 0xcb, 0x9f, 0x30, 0x68, 0xec, 0x77, 0xf2, 0x43, 0x6e, 0xa0, 0x9d, 0xd2, 0xb7,
	0x7b, 0xce, 0xf9, 0x71, 0x98, 0x9b, 0x5c, 0xb0, 0x9a, 0x7d, 0x45, 0xea, 0x7d, 0x55, 0x97, 0x4d,
	0x89, 0x97, 0x55, 0x5a, 0x2b, 0x9a, 0x7d, 0x06, 0x4b, 0xd2, 0xbf, 0x66, 0x4d, 0x4a, 0xa5, 0x3f,
	0x09, 0xa7, 0x70, 0x99, 0x95, 0x8f, 0x65, 0xed, 0x98, 0xae, 0x31, 0xbf, 0x16, 0x07, 0x81, 0x0e,
	0x0c, 0xf3, 0x03, 0xe0, 0x5c, 0xb8, 0xc6, 0x7c, 0x24, 0xb4, 0x44, 0x84, 0x41, 0xb3, 0xcb, 0xc9,
	0x19, 0xb8, 0xc6, 0xfc, 0x42, 0x74, 0xf3, 0x6c, 0x05, 0xb6, 0xff, 0x2b, 0x2d, 0x0a, 0x7a, 0xd4,
	0xad, 0x6f, 0x61, 0xa4, 0x2a, 0x4a, 0x7f, 0x53, 0x1d, 0x2c, 0xba, 0x86, 0xb1, 0xe8, 0x8d, 0xf3,
	0xf6, 0x41, 0x97, 0x69, 0x39, 0xfb, 0x0a, 0x93, 0x28, 0xdd, 0xe7, 0x54, 0x34, 0x82, 0x54, 0x55,
	0x16, 0x8a, 0x5a, 0x58, 0xfd, 0xc9, 0x32, 0x52, 0xca, 0x31, 0x5c, 0x63, 0x7e, 0x25, 0xb4, 0xc4,
	0x37, 0x70, 0x55, 0x1f, 0xa9, 0xee, 0xf5, 0x23, 0x71, 0xd2, 0x68, 0x83, 0x79, 0xfc, 0xf3, 0x48,
	0x98, 0xc1, 0x62, 0xf6, 0x00, 0xf6, 0xb1, 0x38, 0x28, 0xfe, 0x96, 0xbb, 0xac, 0x5f, 0xc4, 0xe8,
	0x17, 0x41, 0x17, 0xac, 0xac, 0xa6, 0xb4, 0xa1, 0x1f, 0x7e, 0xb9, 0x2b, 0xba, 0xd2, 0xb1, 0x38,
	0xb7, 0xda, 0xaf, 0x72, 0xca, 0xcb, 0x63, 0x73, 0x37, 0xbf, 0xfb, 0x6f, 0xc2, 0x40, 0xee, 0x2b,
	0x42, 0x0b, 0x86, 0xe1, 0x26, 0x91, 0xdb, 0x88, 0xb3, 0x67, 0xc8, 0x60, 0x2c, 0xf9, 0x37, 0x99,
	0xac, 0x79, 0x1c, 0x7b, 0x4b, 0xce, 0x0c, 0xbc, 0x81, 0x89, 0xbf, 0xf2, 0xc2, 0x90, 0x7f, 0x3a,
	0x99, 0x66, 0x8b, 0xdd, 0x2f, 0xee, 0x92, 0xe8, 0x3e, 0x5e, 0x25, 0x1f, 0xf9, 0x96, 0x01, 0xbe,
	0x86, 0xdb, 0x73, 0x27, 0x11, 0x3c, 0x8e, 0x36, 0x61, 0xcc, 0x99, 0x85, 0x13, 0xb0, 0xda, 0x68,
	0xc9, 0x65, 0xc7, 0x8e, 0xd1, 0x81, 0xe9, 0x99, 0xd1, 0xa3, 0x2f, 0x74, 0xaf, 0xe0, 0xcb, 0x20,
	0x96, 0x5c, 0x30, 0x5b, 0xf7, 0x6a, 0xa7, 0x87, 0x27, 0x68, 0x03, 0xb4, 0x51, 0xcc, 0x3d, 0xe1,
	0xaf, 0x18, 0xc3, 0x57, 0x70, 0xd3, 0xeb, 0x1e, 0xbc, 0x6e, 0x83, 0xc8, 0xdb, 0xae, 0x79, 0x28,
	0x13, 0x29, 0xbc, 0x30, 0xf6, 0x7c, 0x19, 0x6c, 0x42, 0x36, 0xc5, 0x29, 0x30, 0x1d, 0x9c, 0xf0,
	0xdb, 0x76, 0x63, 0xed, 0x06, 0xe1, 0x97, 0x4d, 0xe0, 0x73, 0xf6, 0xf2, 0x6e, 0xf8, 0x70, 0xb8,
	0xc4, 0xef, 0xcf, 0xbb, 0xbb, 0xfc, 0xf0, 0x14, 0x00, 0x00, 0xff, 0xff, 0x47, 0x3d, 0xa7, 0xff,
	0xa6, 0x02, 0x00, 0x00,
}
